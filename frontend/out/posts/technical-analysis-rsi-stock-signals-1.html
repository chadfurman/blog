<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/0f3a385557f1712f-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/47cbc4e2adbc5db9-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/b0088cce7ac0b424-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/f99df3fdcaccf891-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/5ddd17f1b1872fec.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/1eddb28ba33f8288.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-4e54ab7f9f7bf0b1.js"/><script src="/_next/static/chunks/4bd1b696-19c925b0e560c6b8.js" async=""></script><script src="/_next/static/chunks/517-02059e5e903d874c.js" async=""></script><script src="/_next/static/chunks/main-app-c10f907723d91fa1.js" async=""></script><script src="/_next/static/chunks/839-b13de2d1bed67172.js" async=""></script><script src="/_next/static/chunks/781-88cfb269ae9bc8ae.js" async=""></script><script src="/_next/static/chunks/app/posts/%5Bslug%5D/page-776e7d480274a0fa.js" async=""></script><script src="/_next/static/chunks/531-24c3a792349e7d2c.js" async=""></script><script src="/_next/static/chunks/app/layout-0b257c0388661432.js" async=""></script><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-HBRN8ECZ6C" as="script"/><meta name="next-size-adjust"/><title>Chad Furman</title><meta name="description" content="Mindful code and creativity.  Blog posts on various topics that interest me"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_11c732 __variable_a621cf antialiased"><header class="lg:grid lg:grid-rows-1 lg:grid-cols-5 py-4 border-b border-dotted border-lowlight items-center"><div class="col-span-1 md:col-span-2"><a href="/"><h1 class="mx-auto m-0 w-fit hover:text-lowlight">Chad&#x27;s Website</h1><h2 class="mx-auto m-0 w-fit text-sm tracking-[0.35em]">Mindful code and creativity</h2></a></div><nav class="primary-nav col-span-3 md:col-span-2 flex flex-row justify-around items-center lg:mt-0 mt-4"><a href="/">Home</a><a href="/projects">Projects</a><a href="/posts">Blog</a></nav><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></header><main class="min-h-screen mx-auto px-4 sm:px-6 lg:px-8 max-w-screen-xl "><div class="p-4"><h1>The TA-Lib Conversion: Part 1 - A New Foundation in Rust</h1><p>Converting TA-Lib technical indicators from C to Rust</p><div><h3><strong>The TA-Lib Conversion: Part 1 - A New Foundation in Rust</strong></h3>
<p>In a previous post, we explored the practical profitability of a single technical indicator: the RSI. That exploration—grounded in data and code—is the essence of what I love to do. But to analyze more complex strategies, we need a robust toolkit. For decades, the undisputed champion in that arena has been TA-Lib.</p>
<p>TA-Lib is a titan. First released in 2001, its C/C++ engine is the gold standard for technical analysis, powering countless trading applications worldwide. It&#x27;s stable, reliable, and battle-tested over 20 years of use. But as the official FAQ notes, its very stability and the difficulty of contributing new functions in C have led to a slowdown in innovation.</p>
<p>This is where our new adventure begins.</p>
<p>This blog series will document a massive undertaking: <strong>a complete, native conversion of TA-Lib to Rust.</strong> Why Rust? For the same reasons developers are flocking to it for high-performance applications: memory safety without a garbage collector, incredible speed, and a modern toolchain that makes development a joy. The official TA-Lib project has an ongoing initiative to create a Rust version, and we&#x27;re picking up that torch to explore what it takes to bring this legendary library into the future.</p>
<h4><strong>The Strategy: Don&#x27;t Rewrite, <em>Generate</em>.</strong></h4>
<p>Converting over 150 indicators by hand would be a recipe for madness. It would be tedious, error-prone, and nearly impossible to verify. Thankfully, the original author of TA-Lib, Mario Fortier, gave us a better way.</p>
<p>The unsung hero of the entire TA-Lib project is a C program tucked away in the tools directory: gen_code.</p>
<p>gen_code is a powerful meta-program. It doesn&#x27;t calculate moving averages; it writes the code that calculates moving averages. It reads from a series of abstract table definitions (table_a.c, table_b.c, etc.) that define the name, parameters, inputs, and outputs for every function in the library. From these definitions, it automatically generates the boilerplate C/C++ code, the .NET and Java wrappers, and much more. It&#x27;s the key to TA-Lib&#x27;s cross-platform success.</p>
<p>Our strategy is to harness this existing generator. Instead of rewriting everything, we are teaching the old master a new trick. We&#x27;re extending gen_code by adding a gen_rust.c module that generates proper Rust function signatures and integrates seamlessly with the existing multi-language framework.</p>
<h4><strong>The Technical Challenges: When C Meets Rust</strong></h4>
<p>The conversion revealed fascinating challenges at the intersection of two very different programming paradigms. Here are the key battles we fought and won:</p>
<p><strong>Challenge 1: The For-Loop Syntax Chasm</strong>
C&#x27;s flexible for-loops with multiple increment operations simply don&#x27;t exist in Rust:</p>
<pre><code class="language-c">// C syntax that Rust can&#x27;t handle
for(i=startIdx, outIdx=0; i &lt;= endIdx; i++, outIdx++)
</code></pre>
<p>Our solution? A sophisticated macro system that transforms syntax at the preprocessor level:</p>
<pre><code class="language-c">// Cross-language macro abstraction
#if defined(_RUST)
    #define FOR_EACH_OUTPUT(startVal, endVal, idxVar, outIdxVar) \
    outIdxVar = 0; \
    for idxVar in (startVal as usize)..=(endVal as usize) {
    #define FOR_EACH_OUTPUT_END(outIdxVar) outIdxVar += 1; }
#else
    #define FOR_EACH_OUTPUT(startVal, endVal, idxVar, outIdxVar) \
    for(idxVar=startVal, outIdxVar=0; idxVar &lt;= endVal; idxVar++, outIdxVar++) {
    #define FOR_EACH_OUTPUT_END(outIdxVar) }
#endif
</code></pre>
<p>This macro system successfully converts ~65% of TA-Lib&#x27;s loop patterns automatically.</p>
<p><strong>Challenge 2: Variable Declaration Syntax</strong>
C and Rust declare variables completely differently. Our macro solution:</p>
<pre><code class="language-c">#if defined(_RUST)
    #define DECLARE_INT_VAR(name) let mut name: i32;
    #define DECLARE_INDEX_VAR(name) let mut name: usize;
#else
    #define DECLARE_INT_VAR(name) int name;
    #define DECLARE_INDEX_VAR(name) int name;
#endif
</code></pre>
<p><strong>Challenge 3: The f32 to f64 Type Conversion Problem</strong>
Single precision functions take f32 inputs but must write to f64 output arrays. Direct assignment fails with type mismatches. We solved this with the OUTPUT_F64 macro:</p>
<pre><code class="language-c">#if defined(_RUST)
    #define OUTPUT_F64(val) ((val) as f64)
#else
    #define OUTPUT_F64(val) (val)  // C handles conversion implicitly
#endif
</code></pre>
<p><strong>Challenge 4: Function Signature Generation</strong>
Generating proper Rust function signatures required sophisticated logic in gen_rust.c:</p>
<ul class="list-disc pl-8">
<li>Automatic parameter name conversion to snake_case</li>
<li>Proper Rust reference types (<code>&amp;[f64]</code>, <code>&amp;mut [f64]</code>, <code>&amp;mut i32</code>)</li>
<li>Handling both single and double precision variants</li>
<li>Adding <code>pub</code> keywords for external visibility</li>
</ul>
<p>The result? Clean, idiomatic Rust signatures:</p>
<pre><code class="language-rust">pub fn mult(start_idx: i32,
            end_idx: i32, 
            in_real0: &amp;[f64],
            in_real1: &amp;[f64],
            out_beg_idx: &amp;mut i32,
            out_nb_element: &amp;mut i32,
            out_real: &amp;mut [f64]) -&gt; RetCode {
    // Implementation generated from C source
}
</code></pre>
<h4><strong>The Build Process Revolution</strong></h4>
<p>We didn&#x27;t stop at code generation. We integrated Rust tooling directly into the build process:</p>
<ul class="list-disc pl-8">
<li>Automatic <code>cargo fix --lib -p ta-lib --allow-dirty</code> for linting</li>
<li>Automatic <code>cargo fmt</code> for consistent formatting</li>
<li>Multi-path cargo detection for cross-platform compatibility</li>
<li>Comprehensive test suite generation and execution</li>
</ul>
<p>The gen_code now produces not just working Rust code, but properly formatted, linted, and tested Rust code.</p>
<h4><strong>Testing and Validation: Trust but Verify</strong></h4>
<p>With great power comes great responsibility. A code generator that produces incorrect results is worse than no generator at all. Our testing strategy is comprehensive:</p>
<p><strong>Comprehensive Test Coverage:</strong></p>
<ul class="list-disc pl-8">
<li>Double precision and single precision variants</li>
<li>Edge cases (negative indices, invalid ranges)</li>
<li>Partial array processing</li>
<li>Error condition validation</li>
<li>Lookback function testing</li>
</ul>
<p><strong>Example Test Structure:</strong></p>
<pre><code class="language-rust">#[test]
fn test_mult_double_precision() {
    let in_real0 = [1.0, 2.0, 3.0, 4.0, 5.0];
    let in_real1 = [2.0, 3.0, 4.0, 5.0, 6.0];
    let mut out_real = [0.0; 5];
    let mut out_beg_idx = 0i32;
    let mut out_nb_element = 0i32;
    
    let result = Core::mult(0, 4, &amp;in_real0, &amp;in_real1, 
                           &amp;mut out_beg_idx, &amp;mut out_nb_element, 
                           &amp;mut out_real);
    
    assert_eq!(result, RetCode::Success);
    assert_eq!(out_nb_element, 5);
    // Verify each calculation: [2.0, 6.0, 12.0, 20.0, 30.0]
}
</code></pre>
<p><strong>Automated Quality Assurance:</strong>
Every generated function goes through:</p>
<ol>
<li><code>cargo check</code> - Rust compiler validation</li>
<li><code>cargo fmt</code> - Consistent code formatting</li>
<li><code>cargo fix</code> - Automatic linting fixes</li>
<li><code>cargo test</code> - Comprehensive test execution</li>
</ol>
<h4><strong>The Architecture: Single Source, Multiple Targets</strong></h4>
<p>The elegance of our solution lies in maintaining Mario Fortier&#x27;s original architectural principle: <strong>single source of truth</strong>. The same <code>ta_MULT.c</code> file now generates correct code for four different languages:</p>
<pre><code class="language-c">/* Generated */ #if defined( _MANAGED )
/* Generated */ public: enum class Core::RetCode Core::MULT(...)
/* Generated */ #elif defined( _JAVA )
/* Generated */ public RetCode mult(...)
/* Generated */ #elif defined( _RUST )
/* Generated */ pub fn mult(...) -&gt; RetCode
/* Generated */ #else
/* Generated */ TA_LIB_API TA_RetCode TA_MULT(...)
/* Generated */ #endif
</code></pre>
<p>This preserves the maintainability that has made TA-Lib successful for over two decades while extending it to modern languages.</p>
<h4><strong>What&#x27;s Next</strong></h4>
<p>We&#x27;ve proven the concept with a simple mathematical function and built a robust foundation for cross-language code generation. The real test will come as we tackle the classic indicators that form the backbone of technical analysis.</p>
<p>Our roadmap includes some of the most fundamental indicators: Simple Moving Average (SMA), Exponential Moving Average (EMA), and the Relative Strength Index (RSI) - the same RSI we explored for profitability in our previous analysis. Each presents unique challenges: SMA with its windowed calculations, EMA with its recursive nature, and RSI with its complex multi-step algorithm.</p>
<p>The journey ahead is ambitious, and we&#x27;ll share our progress as we go. Some indicators will convert smoothly with our existing macro system. Others may require new techniques and creative solutions. That&#x27;s the nature of pushing boundaries - you discover the limits as you test them.</p>
<p>Stay tuned. We&#x27;re building something significant, one function at a time.</p></div></div></main><script src="/_next/static/chunks/webpack-4e54ab7f9f7bf0b1.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"7:\"$Sreact.fragment\"\n8:I[4839,[\"839\",\"static/chunks/839-b13de2d1bed67172.js\",\"781\",\"static/chunks/781-88cfb269ae9bc8ae.js\",\"858\",\"static/chunks/app/posts/%5Bslug%5D/page-776e7d480274a0fa.js\"],\"\"]\n9:I[4684,[\"839\",\"static/chunks/839-b13de2d1bed67172.js\",\"531\",\"static/chunks/531-24c3a792349e7d2c.js\",\"177\",\"static/chunks/app/layout-0b257c0388661432.js\"],\"default\"]\na:I[5244,[],\"\"]\nb:I[3866,[],\"\"]\nc:I[3781,[\"839\",\"static/chunks/839-b13de2d1bed67172.js\",\"781\",\"static/chunks/781-88cfb269ae9bc8ae.js\",\"858\",\"static/chunks/app/posts/%5Bslug%5D/page-776e7d480274a0fa.js\"],\"default\"]\nd:I[3795,[\"839\",\"static/chunks/839-b13de2d1bed67172.js\",\"531\",\"static/chunks/531-24c3a792349e7d2c.js\",\"177\",\"static/chunks/app/layout-0b257c0388661432.js\"],\"default\"]\ne:I[766,[\"839\",\"static/chunks/839-b13de2d1bed67172.js\",\"531\",\"static/chunks/531-24c3a792349e7d2c.js\",\"177\",\"static/chunks/app/layout-0b257c0388661432.js\"],\"GoogleAnalytics\"]\n10:I[6213,[],\"OutletBoundary\"]\n12:I[6213,[],\"MetadataBoundary\"]\n14:I[6213,[],\"ViewportBoundary\"]\n16:I[4835,[],\"\"]\n1:HL[\"/_next/static/media/0f3a385557f1712f-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/media/47cbc4e2adbc5db9-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n3:HL[\"/_next/static/media/b0088cce7ac0b424-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n4:HL[\"/_next/static/media/f99df3fdcaccf891-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n5:HL[\"/_next/static/css/5ddd17f1b1872fec.css\",\"style\"]\n6:HL[\"/_next/static/css/1eddb28ba33f8288.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"GAv23UfDoDJrXRlA_bm5J\",\"p\":\"\",\"c\":[\"\",\"posts\",\"technical-analysis-rsi-stock-signals-1\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"technical-analysis-rsi-stock-signals-1\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$7\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/5ddd17f1b1872fec.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/1eddb28ba33f8288.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_11c732 __variable_a621cf antialiased\",\"children\":[[\"$\",\"header\",null,{\"className\":\"lg:grid lg:grid-rows-1 lg:grid-cols-5 py-4 border-b border-dotted border-lowlight items-center\",\"children\":[[\"$\",\"div\",null,{\"className\":\"col-span-1 md:col-span-2\",\"children\":[\"$\",\"$L8\",null,{\"href\":\"/\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"mx-auto m-0 w-fit hover:text-lowlight\",\"children\":\"Chad's Website\"}],[\"$\",\"h2\",null,{\"className\":\"mx-auto m-0 w-fit text-sm tracking-[0.35em]\",\"children\":\"Mindful code and creativity\"}]]}]}],[\"$\",\"nav\",null,{\"className\":\"primary-nav col-span-3 md:col-span-2 flex flex-row justify-around items-center lg:mt-0 mt-4\",\"children\":[[\"$\",\"$L8\",null,{\"href\":\"/\",\"children\":\"Home\"}],[\"$\",\"$L8\",null,{\"href\":\"/projects\",\"children\":\"Projects\"}],[\"$\",\"$L8\",null,{\"href\":\"/posts\",\"children\":\"Blog\"}]]}],[\"$\",\"$L9\",null,{}]]}],[\"$\",\"main\",null,{\"className\":\"min-h-screen mx-auto px-4 sm:px-6 lg:px-8 max-w-screen-xl \",\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"sm:h-[30rem] lg:h-[40rem] grid grid-cols-2  grid-flow-dense\",\"children\":[[\"$\",\"div\",null,{\"className\":\"my-auto col-start-2 sm:pl-16 md:pl-32 lg:pl-48\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"my-2 mx-auto sm:mx-0 w-fit tracking-[.1em] lg:mt-8 sm:text-2xl md:text-4xl lg:text-8xl\",\"children\":\"404?!\"}],[\"$\",\"h3\",null,{\"className\":\"w-fit mx-auto sm:mx-0 tracking-[.1em] my-1 text-highlight/[.9] sm:text-xl md:text-2xl lg:text-4xl\",\"children\":\"Oh no!\"}],[\"$\",\"p\",null,{\"className\":\"text-center sm:text-left leading-4 link-styles\",\"children\":[\"$\",\"$L8\",null,{\"href\":\"/\",\"children\":\"Return Home\"}]}]]}],[\"$\",\"div\",null,{\"className\":\"py-20 mx-14 relative\",\"children\":[\"$\",\"$Lc\",null,{\"alt\":\"Chad is shocked by the 404\",\"src\":{\"src\":\"/_next/static/media/shocked-chad.41fcb102.png\",\"height\":1024,\"width\":1024,\"blurDataURL\":\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAMAAADz0U65AAAAYFBMVEW3pLdJPjvyoIaLSTljUkebgnIzKCZ2Y1gzHR1VTUlUS0akmZqJdGeyn4lrYVumnpc7Ly8RDhWVlZz///+2fWWYmJ+1fWUeFhihj3yejXqblZCslYS3noVgV1LhxKN3b2i1u1ppAAAAHXRSTlMBKx0hhP468hf5l+f+/fv+a0dBDOdD6lz9/f36/oQ6HcYAAAAJcEhZcwAACxMAAAsTAQCanBgAAABFSURBVHicFctHEsAgDASwBQzG1PQO+f8vM9FdgFcUHACEt14yAK5UeydR2Fvq/SkjPLfzEPbQm83ZLhqzIWYyf1tjnIAPaGwCzCt6y+0AAAAASUVORK5CYII=\",\"blurWidth\":8,\"blurHeight\":8},\"fill\":true,\"className\":\"object-contain\"}]}]]}],\"notFoundStyles\":[]}]}],[\"$\",\"$Ld\",null,{}],[\"$\",\"$Le\",null,{\"gaId\":\"G-HBRN8ECZ6C\"}]]}]}]]}],{\"children\":[\"posts\",[\"$\",\"$7\",\"c\",{\"children\":[null,[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"technical-analysis-rsi-stock-signals-1\",\"d\"],[\"$\",\"$7\",\"c\",{\"children\":[null,[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$7\",\"c\",{\"children\":[\"$Lf\",null,[\"$\",\"$L10\",null,{\"children\":\"$L11\"}]]}],{},null]},null]},null]},null],[\"$\",\"$7\",\"h\",{\"children\":[null,[\"$\",\"$7\",\"Xv-oRmkdrGUV8T7tIWkbV\",{\"children\":[[\"$\",\"$L12\",null,{\"children\":\"$L13\"}],[\"$\",\"$L14\",null,{\"children\":\"$L15\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\"}]]}]]}]]],\"m\":\"$undefined\",\"G\":[\"$16\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"f:[\"$\",\"div\",null,{\"className\":\"p-4\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"The TA-Lib Conversion: Part 1 - A New Foundation in Rust\"}],[\"$\",\"p\",null,{\"children\":\"Converting TA-Lib technical indicators from C to Rust\"}],[\"$L17\"]]}]\n"])</script><script>self.__next_f.push([1,"17:[\"$\",\"div\",\"27\",{\"children\":\"$L18\"}]\n"])</script><script>self.__next_f.push([1,"18:[[\"$\",\"h3\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"The TA-Lib Conversion: Part 1 - A New Foundation in Rust\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In a previous post, we explored the practical profitability of a single technical indicator: the RSI. That exploration—grounded in data and code—is the essence of what I love to do. But to analyze more complex strategies, we need a robust toolkit. For decades, the undisputed champion in that arena has been TA-Lib.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"TA-Lib is a titan. First released in 2001, its C/C++ engine is the gold standard for technical analysis, powering countless trading applications worldwide. It's stable, reliable, and battle-tested over 20 years of use. But as the official FAQ notes, its very stability and the difficulty of contributing new functions in C have led to a slowdown in innovation.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This is where our new adventure begins.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"This blog series will document a massive undertaking: \",[\"$\",\"strong\",null,{\"children\":\"a complete, native conversion of TA-Lib to Rust.\"}],\" Why Rust? For the same reasons developers are flocking to it for high-performance applications: memory safety without a garbage collector, incredible speed, and a modern toolchain that makes development a joy. The official TA-Lib project has an ongoing initiative to create a Rust version, and we're picking up that torch to explore what it takes to bring this legendary library into the future.\"]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":[\"The Strategy: Don't Rewrite, \",[\"$\",\"em\",null,{\"children\":\"Generate\"}],\".\"]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Converting over 150 indicators by hand would be a recipe for madness. It would be tedious, error-prone, and nearly impossible to verify. Thankfully, the original author of TA-Lib, Mario Fortier, gave us a better way.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The unsung hero of the entire TA-Lib project is a C program tucked away in the tools directory: gen_code.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"gen_code is a powerful meta-program. It doesn't calculate moving averages; it writes the code that calculates moving averages. It reads from a series of abstract table definitions (table_a.c, table_b.c, etc.) that define the name, parameters, inputs, and outputs for every function in the library. From these definitions, it automatically generates the boilerplate C/C++ code, the .NET and Java wrappers, and much more. It's the key to TA-Lib's cross-platform success.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Our strategy is to harness this existing generator. Instead of rewriting everything, we are teaching the old master a new trick. We're extending gen_code by adding a gen_rust.c module that generates proper Rust function signatures and integrates seamlessly with the existing multi-language framework.\"}],\"\\n\",[\"$\",\"h4\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"The Technical Challenges: When C Meets Rust\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The conversion revealed fascinating challenges at the intersection of two very different programming paradigms. Here are the key battles we fought and won:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Challenge 1: The For-Loop Syntax Chasm\"}],\"\\nC's flexible for-loops with multiple increment operations simply don't exist in Rust:\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-c\",\"children\":\"// C syntax that Rust can't handle\\nfor(i=startIdx, outIdx=0; i \u003c= endIdx; i++, outIdx++)\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Our solution? A sophisticated macro system that transforms syntax at the preprocessor level:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-c\",\"children\":\"// Cross-language macro abstraction\\n#if defined(_RUST)\\n    #define FOR_EACH_OUTPUT(startVal, endVal, idxVar, outIdxVar) \\\\\\n    outIdxVar = 0; \\\\\\n    for idxVar in (startVal as usize)..=(endVal as usize) {\\n    #define FOR_EACH_OUTPUT_END(outIdxVar) outIdxVar += 1; }\\n#else\\n    #define FOR_EACH_OUTPUT(startVal, endVal, idxVar, outIdxVar) \\\\\\n    for(idxVar=startVal, outIdxVar=0; idxVar \u003c= endVal; idxVar++, outIdxVar++) {\\n    #define FOR_EACH_OUTPUT_END(outIdxVar) }\\n#endif\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This macro system successfully converts ~65% of TA-Lib's loop patterns automatically.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Challenge 2: Variable Declaration Syntax\"}],\"\\nC and Rust declare variables completely differently. Our macro solution:\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-c\",\"children\":\"#if defined(_RUST)\\n    #define DECLARE_INT_VAR(name) let mut name: i32;\\n    #define DECLARE_INDEX_VAR(name) let mut name: usize;\\n#else\\n    #define DECLARE_INT_VAR(name) int name;\\n    #define DECLARE_INDEX_VAR(name) int name;\\n#endif\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Challenge 3: The f32 to f64 Type Conversion Problem\"}],\"\\nSingle precision functions take f32 inputs but must write to f64 output arrays. Direct assignment fails with type mismatches. We solved this with the OUTPUT_F64 macro:\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-c\",\"children\":\"#if defined(_RUST)\\n    #define OUTPUT_F64(val) ((val) as f64)\\n#else\\n    #define OUTPUT_F64(val) (val)  // C handles conversion implicitly\\n#endif\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Challenge 4: Function Signature Generation\"}],\"\\nGenerating proper Rust function signatures required sophisticated logic in gen_rust.c:\"]}],\"\\n\",[\"$\",\"ul\",null,{\"className\":\"list-disc pl-8\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Automatic parameter name conversion to snake_case\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Proper Rust reference types (\",[\"$\",\"code\",null,{\"children\":\"\u0026[f64]\"}],\", \",[\"$\",\"code\",null,{\"children\":\"\u0026mut [f64]\"}],\", \",[\"$\",\"code\",null,{\"children\":\"\u0026mut i32\"}],\")\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Handling both single and double precision variants\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Adding \",[\"$\",\"code\",null,{\"children\":\"pub\"}],\" keywords for external visibility\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The result? Clean, idiomatic Rust signatures:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-rust\",\"children\":\"pub fn mult(start_idx: i32,\\n            end_idx: i32, \\n            in_real0: \u0026[f64],\\n            in_real1: \u0026[f64],\\n            out_beg_idx: \u0026mut i32,\\n            out_nb_element: \u0026mut i32,\\n            out_real: \u0026mut [f64]) -\u003e RetCode {\\n    // Implementation generated from C source\\n}\\n\"}]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"The Build Process Revolution\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We didn't stop at code generation. We integrated Rust tooling directly into the build process:\"}],\"\\n\",[\"$\",\"ul\",null,{\"className\":\"list-disc pl-8\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Automatic \",[\"$\",\"code\",null,{\"children\":\"cargo fix --lib -p ta-lib --allow-dirty\"}],\" for linting\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Automatic \",[\"$\",\"code\",null,{\"children\":\"cargo fmt\"}],\" for consistent formatting\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Multi-path cargo detection for cross-platform compatibility\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Comprehensive test suite generation and execution\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The gen_code now produces not just working Rust code, but properly formatted, linted, and tested Rust code.\"}],\"\\n\",[\"$\",\"h4\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"Testing and Validation: Trust but Verify\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"With great power comes great responsibility. A code generator that produces incorrect results is worse than no generator at all. Our testing strategy is comprehensive:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"Comprehensive Test Coverage:\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"className\":\"list-disc pl-8\",\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Double precision and single precision variants\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Edge cases (negative indices, invalid ranges)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Partial array processing\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Error condition validation\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"Lookback function testing\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"Example Test Structure:\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-rust\",\"children\":\"#[test]\\nfn test_mult_double_precision() {\\n    let in_real0 = [1.0, 2.0, 3.0, 4.0, 5.0];\\n    let in_real1 = [2.0, 3.0, 4.0, 5.0, 6.0];\\n    let mut out_real = [0.0; 5];\\n    let mut out_beg_idx = 0i32;\\n    let mut out_nb_element = 0i32;\\n    \\n    let result = Core::mult(0, 4, \u0026in_real0, \u0026in_real1, \\n                           \u0026mut out_beg_idx, \u0026mut out_nb_element, \\n                           \u0026mut out_real);\\n    \\n    assert_eq!(result, RetCode::Success);\\n    assert_eq!(out_nb_element, 5);\\n    // Verify each calculation: [2.0, 6.0, 12.0, 20.0, 30.0]\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Automated Quality Assurance:\"}],\"\\nEvery generated function goes through:\"]}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"cargo check\"}],\" - Rust compiler validation\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"cargo fmt\"}],\" - Consistent code formatting\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"cargo fix\"}],\" - Automatic linting fixes\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"cargo test\"}],\" - Comprehensive test execution\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"The Architecture: Single Source, Multiple Targets\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The elegance of our solution lies in maintaining Mario Fortier's original architectural principle: \",[\"$\",\"strong\",null,{\"children\":\"single source of truth\"}],\". The same \",[\"$\",\"code\",null,{\"children\":\"ta_MULT.c\"}],\" file now generates correct code for four different languages:\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-c\",\"children\":\"/* Generated */ #if defined( _MANAGED )\\n/* Generated */ public: enum class Core::RetCode Core::MULT(...)\\n/* Generated */ #elif defined( _JAVA )\\n/* Generated */ public RetCode mult(...)\\n/* Generated */ #elif defined( _RUST )\\n/* Generated */ pub fn mult(...) -\u003e RetCode\\n/* Generated */ #else\\n/* Generated */ TA_LIB_API TA_RetCode TA_MULT(...)\\n/* Generated */ #endif\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This preserves the maintainability that has made TA-Lib successful for over two decades while extending it to modern languages.\"}],\"\\n\",[\"$\",\"h4\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"What's Next\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We've proven the concept with a simple mathematical function and built a robust foundation for cross-language code generation. The real test will come as we tackle the classic indicators that form the backbone of technical analysis.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Our roadmap includes some of the most fundamental indicators: Simple Moving Average (SMA), Exponential Moving Average (EMA), and the Relative Strength Index (RSI) - the same RSI we explored for profitability in our previous analysis. Each presents unique challenges: SMA with its windowed calculations, EMA with its recursive nature, and RSI with its complex multi-step algorithm.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The journey ahead is ambitious, and we'll share our progress as we go. Some indicators will convert smoothly with our existing macro system. Others may require new techniques and creative solutions. That's the nature of pushing boundaries - you discover the limits as you test them.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Stay tuned. We're building something significant, one function at a time.\"}]]\n"])</script><script>self.__next_f.push([1,"15:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n13:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Chad Furman\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Mindful code and creativity.  Blog posts on various topics that interest me\"}]]\n"])</script><script>self.__next_f.push([1,"11:null\n"])</script></body></html>